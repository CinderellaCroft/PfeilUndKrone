# Fortsetzung der Projektdokumentation - Technische Implementierung

## Hauptteil - Technische Umsetzung

### Architektur-Übersicht

Die technische Umsetzung des Spiels "Pfeil und Krone" basiert auf einer Client-Server-Architektur, die eine Trennung von Spiellogik und Präsentation ermöglicht. Diese Architektur wurde bewusst gewählt, um die Multiplayer-Funktionalität robust und skalierbar zu implementieren.

#### Client-Seite (Unity)
Die Client-Implementierung erfolgte in Unity 6000.0.49f1 mit C#. Die Entscheidung für Unity fiel aufgrund der plattformübergreifenden Unterstützung, der umfangreichen Asset-Pipeline und der etablierten Entwicklungsumgebung für 3D-Spiele. Die Built-in Render Pipeline wurde bewusst gewählt, um eine breite Hardware-Kompatibilität zu gewährleisten.

**Hauptkomponenten der Client-Architektur:**

**Manager-Pattern**: Das Spiel verwendet ein Manager-System zur Trennung der Verantwortlichkeiten:
- `GameManager.cs`: Koordiniert den gesamten Spielablauf und verwaltet den Spielzustand
- `InteractionManager.cs`: Behandelt Benutzerinteraktionen und Spielregeln
- `UIManager.cs`: Verwaltet die gesamte Benutzeroberfläche
- `GridVisualsManager.cs`: Steuert die visuelle Darstellung des Spielfelds
- `NetworkManager.cs`: Behandelt die Kommunikation mit dem Server

**Hexagon-Grid-System**: Das Spielfeld basiert auf einem hexagonalen Koordinatensystem, implementiert in `HexGrid.cs` und `HexGridModel.cs`. Diese Struktur ermöglicht die mathematisch korrekte Berechnung von Nachbarschaftsbeziehungen und Pfaden zwischen den sechseckigen Feldern.

**Netzwerk-Architektur**: Die Kommunikation erfolgt über WebSockets mit einem strukturierten DTO-System (`NetworkingDTOs.cs`), das eine typisierte und erweiterbare Nachrichtenübertragung ermöglicht.

#### Server-Seite (Node.js)
Der Server wurde in JavaScript mit Node.js implementiert und verwendet WebSockets für die Echtzeitkommunikation. Die modulare Struktur ermöglicht eine klare Trennung der Funktionalitäten:

**Kernmodule:**
- `server.js`: Hauptserverlogik, Client-Verbindungsmanagement und Spielablauf
- `util.js`: Hilfsfunktionen, Spielzustandsverwaltung und Berechnungslogik
- `lobby.js`: Lobby-System für Spielermatching und Raumverwaltung
- `GenerateResourceMap.js`: Prozedurelle Generierung der Ressourcenkarten

### Spielmechanik-Implementierung

#### Ressourcenmanagement-System
Das Balancing wurde durch umfangreiche Tests und iterative Anpassungen entwickelt:

**Startressourcen:**
- König: 0 Gold, 20 Holz, 50 Getreide
- Bandit: 0 Gold, 30 Holz, 20 Getreide

Diese asymmetrische Verteilung reflektiert die unterschiedlichen Spielstile: Der König startet mit mehr Getreide für die Arbeiterversorgung, während der Bandit mehr Holz für frühe Ambush-Aktionen erhält.

**Kostenstruktur:**
- Arbeiter-Kauf: 20 Getreide + 8 Holz
- Wagen-Upgrade: 25 Holz
- Ambush-Kosten: 12 der höchsten Ressource (Holz oder Getreide)

Das dynamische Ambush-Kostensystem verhindert Ressourcen-Hoarding und zwingt den Banditen zu ausgewogener Ressourcenverwaltung.

#### Wegfindungs-Algorithmus
Das Spiel implementiert ein Corner-basiertes Wegfindungssystem, das auf den Kanten des Hexagon-Grids operiert. Jede Ecke eines Hexagons kann als Wegpunkt dienen, wodurch sechs mögliche Verbindungen pro Hexagon entstehen.

**Pfad-Validierung:**
- Startpunkt muss eine gültige Corner-Position sein
- Jeder nachfolgende Punkt muss adjazent zum vorherigen sein
- Der Endpunkt muss das zentrale Burgfeld erreichen
- Pfadlänge beeinflusst den Ressourcenertrag durch Decay-Mechanik

#### Ressourcen-Decay-System
Die Ressourcenberechnung folgt der Formel:
```
Endwert = Grundwert - (Pfadlänge × Decay-Rate)
Grundwert = Distanz_zum_Zentrum × 15
Decay-Rate = 3 (normale Arbeiter) | 1.5 (Wagen-Arbeiter)
Minimalwert = 8 Ressourcen
```

Diese Mechanik belohnt effiziente Pfade und macht Wagen-Upgrades für längere Distanzen attraktiv.

### Netzwerk-Protokoll und Synchronisation

#### WebSocket-Kommunikation
Das Spiel verwendet ein ereignisbasiertes Protokoll mit strukturierten Nachrichten:

**Nachrichtentypen:**
- `match_created`: Spielinitialisierung und Rollenzuweisung
- `resource_map`: Übertragung der Spielfeldkonfiguration
- `new_round`: Rundenbeginn mit aktualisiertem Spielzustand
- `king_turn_start`/`bandit_turn_start`: Zugphasen-Management
- `game_over`: Spielende mit Gewinn-/Verlustgrund

#### Zustandssynchronisation
Der Server fungiert als autoritäre Instanz für den Spielzustand. Client-Aktionen werden validiert und der aktualisierte Zustand an beide Spieler übertragen. Diese Architektur verhindert Cheating und gewährleistet Konsistenz.

**Validierungsmechanismen:**
- Server-seitige Kostenprüfung vor Aktionsausführung
- Pfad-Validierung gegen Spielregeln
- Ressourcen-Konsistenzprüfung

### Sieg- und Niederlagen-System

#### Win-Conditions
Das asymmetrische Siegsystem reflektiert die unterschiedlichen Spielziele:
- König: 200 Gold sammeln (wirtschaftlicher Sieg)
- Bandit: 100 Gold sammeln (durch Ambushes)

#### Lose-Conditions
Das System implementiert Ressourcen-Exhaustion als Niederlage-Mechanik:
- König verliert: Keine lebenden Arbeiter UND kann keine neuen kaufen (< 20 Getreide ODER < 8 Holz)
- Bandit verliert: Kann keine Ambushes kaufen (< 12 höchste Ressource)

Diese Mechanik verhindert passive Spielstrategien und zwingt zu aktiver Ressourcenverwaltung.

### Performance-Optimierungen

#### Client-seitige Optimierungen
- **Objekt-Pooling**: Wiederverwendung von GameObjects für bewegende Arbeiter
- **LOD-System**: Reduzierte Komplexität bei größerer Kameradistanz
- **Batch-Rendering**: Zusammenfassung ähnlicher Geometrien
- **UI-Caching**: Minimierung von Text-Updates durch Änderungserkennung

#### Server-seitige Optimierungen
- **Lobby-Isolation**: Getrennte Spielzustände verhindern Cross-Contamination
- **Message-Queuing**: Gepufferte Nachrichten für Client-Reconnects
- **Garbage-Collection**: Automatische Bereinigung leerer Lobbies

### Fehlerbehandlung und Robustheit

#### Client-Reconnection
Das System behandelt Verbindungsabbrüche durch:
- Automatische Reconnection-Versuche
- Zustandswiederherstellung nach Reconnect
- Timeout-Management für inaktive Spieler

#### Server-Stabilität
- **Graceful-Degradation**: Partielle Funktionalität bei Netzwerkproblemen
- **Error-Boundaries**: Isolierung von Fehlern zwischen Lobbies
- **Resource-Cleanup**: Automatische Bereinigung bei Client-Disconnects

### Erweiterbarkeit und Wartbarkeit

#### Modulare Architektur
Das Design unterstützt zukünftige Erweiterungen:
- **Plugin-System**: Neue Spielmodi durch Module
- **Event-System**: Lose gekoppelte Komponenten
- **Configuration-Management**: Externe Balancing-Parameter

#### Code-Organisation
- **Separation of Concerns**: Klare Verantwortlichkeitstrennung
- **Dependency Injection**: Testbare und austauschbare Komponenten
- **Factory Patterns**: Flexible Objekterstellung

### Testing und Quality Assurance

#### Automatisierte Tests
- **Unit Tests**: Kern-Algorithmen und Berechnungen
- **Integration Tests**: Netzwerk-Protokoll und Synchronisation
- **Performance Tests**: Skalierbarkeit und Resource-Usage

#### Manuelle Testszenarien
- **Balancing-Tests**: Spiellänge und Fairness
- **Usability-Tests**: Intuitive Bedienung und Lernkurve
- **Stress-Tests**: Verhalten bei hoher Last

Die implementierte Architektur bietet eine solide Grundlage für das asymmetrische Tower-Defense-Spiel und unterstützt sowohl die aktuellen Anforderungen als auch zukünftige Erweiterungen. Durch die klare Trennung von Client und Server, das robuste Netzwerk-Protokoll und die durchdachte Spielmechanik entsteht ein stabiles und erweiterbares System, das die strategische Tiefe des Papierprototyps erfolgreich in die digitale Umsetzung überträgt.

## Technische Herausforderungen und Lösungsansätze

### Asymmetrisches Spieldesign in der Implementierung

Die größte technische Herausforderung lag in der Umsetzung des asymmetrischen Spieldesigns. Beide Spieler benötigen unterschiedliche Informationen und Interaktionsmöglichkeiten, müssen aber dennoch auf derselben Spielbasis operieren.

**Lösungsansatz - Selective Information Sharing:**
Das System implementiert rollenbasierte Informationsfilterung:
```javascript
// Server-seitige Implementierung
sendTo(lobby, 'King', { type: 'resource_map', payload: kingsResourceMap });
sendTo(lobby, 'Bandit', { type: 'resource_map', payload: banditsResourceMap });
```

Der König erhält detaillierte Ressourceninformationen, während der Bandit nur eine abstrakte Kartendarstellung sieht. Diese Implementierung erfolgt bereits auf Server-Ebene, wodurch Manipulation ausgeschlossen wird.

### Echtzeit-Synchronisation bei Rundenzügen

Die Koordination zwischen den asynchronen Spielzügen stellte eine komplexe Aufgabe dar. Der König plant seine Züge, während der Bandit gleichzeitig Ambushes platziert, aber beide müssen auf den aktuellen Spielzustand zugreifen.

**Lösungsansatz - State Machine Pattern:**
```javascript
// Zustandsübergänge im Server
function startNewRound(lobby) {
  const gs = lobby.gameState;
  gs.turn = 'KING_PLANNING';
  // Weitere Zustandslogik...
}
```

Das System verwendet einen klar definierten Zustandsautomaten mit expliziten Übergängen zwischen `KING_PLANNING`, `BANDIT_PLANNING` und `EXECUTION`.

### Prozedurelle Kartengeneration

Die Erstellung ausgewogener Spielkarten, die sowohl fair als auch abwechslungsreich sind, erforderte einen durchdachten Algorithmus.

**Lösungsansatz - Constraint-based Generation:**
Die Implementierung in `GenerateResourceMap.js` nutzt:
- Seeded Random Number Generation für reproduzierbare Karten
- Constraint-Validation zur Sicherstellung minimaler Ressourcenverteilung
- Distanz-basierte Balancing für gleichmäßige Ressourcenstreuung

### Cross-Platform Networking

Die WebSocket-Implementierung musste plattformübergreifend funktionieren und robuste Fehlerbehandlung bieten.

**Lösungsansatz - Protocol Abstraction:**
```csharp
// Client-seitige Abstraktion
public class NetworkManager : SingletonNetworkService<NetworkManager>
{
    protected override void ProcessMessage(string message)
    {
        // Plattformunabhängige Nachrichtenverarbeitung
    }
}
```

Die Abstraktion ermöglicht einheitliche Behandlung unabhängig von der Zielplattform.

## Fazit und Ausblick

### Erreichte Projektziele

Das Projekt "Pfeil und Krone" hat seine primären Ziele erfolgreich erreicht:

**Technische Umsetzung:**
- Vollständig funktionsfähiger Multiplayer-Prototyp
- Stabile Client-Server-Architektur mit WebSocket-Kommunikation
- Implementierung aller Kern-Spielmechaniken
- Ausgewogenes Ressourcen- und Balancing-System

**Spieldesign:**
- Erfolgreich umgesetztes asymmetrisches Spieldesign
- Intuitive Benutzeroberfläche mit rollenspezifischen Elementen
- Kohärente visuelle Gestaltung zwischen König und Bandit
- Strategische Tiefe durch Ressourcenmanagement und Pfadplanung

**Projektmanagement:**
- Effektive Aufteilung zwischen Design, Client- und Server-Team
- Regelmäßige Integration und Testing
- Dokumentierte Entwicklungsprozesse und Architekturentscheidungen

### Technische Erkenntnisse

Die Entwicklung erbrachte wertvolle Erkenntnisse für zukünftige Projekte:

**Architektur-Prinzipien:**
- Die klare Trennung von Client und Server vereinfacht Debugging und Erweiterungen
- Event-basierte Kommunikation erhöht die Flexibilität des Systems
- Modulare Code-Organisation erleichtert Teamarbeit und Wartung

**Balancing-Prozess:**
- Iterative Anpassung basierend auf Playtests ist essentiell
- Mathematische Modellierung hilft bei der Vorhersage von Spielverhalten
- Asymmetrisches Design erfordert doppelte Validierung aller Mechaniken

**Performance-Aspekte:**
- Early Optimization kann zu komplexerem Code führen
- Profiling ist wichtiger als Vermutungen über Engpässe
- WebSocket-Overhead ist vernachlässigbar für Turn-based Games

### Kritische Bewertung

**Erfolgreiche Aspekte:**
- Das asymmetrische Design erzeugt tatsächlich unterschiedliche Spielerfahrungen
- Die hexagonale Spielfläche bietet strategische Tiefe ohne Überkomplexität
- Das Ressourcen-Decay-System erzeugt interessante Optimierungsprobleme
- Die visuelle Differenzierung zwischen den Rollen ist gelungen

**Verbesserungspotential:**
- Die Lernkurve für neue Spieler könnte durch Tutorials reduziert werden
- Längere Spielsitzungen könnten durch zusätzliche Mechaniken interessant bleiben
- Der Reconnection-Prozess benötigt weitere Stabilisierung
- Die Skalierung auf mehr als zwei Spieler würde das Konzept erweitern

### Zukünftige Entwicklungsmöglichkeiten

**Kurzfristige Erweiterungen:**
- **Tutorial-System**: Interaktive Einführung für neue Spieler
- **Spektator-Modus**: Zusehen bei laufenden Partien
- **Replay-System**: Aufzeichnung und Wiedergabe von Spielen
- **Statistik-Tracking**: Langzeit-Spielerdaten und Erfolgsmetriken

**Mittelfristige Features:**
- **Kampagnen-Modus**: Verknüpfte Einzelspieler-Missionen
- **Spieler-Ränge**: Competitive Ranking System
- **Custom Maps**: Benutzer-generierte Inhalte
- **Mobile Unterstützung**: Cross-Platform zwischen PC und Mobile

**Langfristige Vision:**
- **4-Spieler Modus**: Zwei Königreiche vs. zwei Banditengruppen
- **Persistente Welten**: MMO-artige Kontinentalentwicklung
- **KI-Gegner**: Maschinelles Lernen für adaptive Computergegner
- **VR-Integration**: Immersive 3D-Steuerung des Spielfelds

### Pädagogische Anwendungsmöglichkeiten

Das entwickelte System bietet Potenzial für Bildungskontext:

**Strategisches Denken:**
- Ressourcenoptimierung und -management
- Langfristige Planungsfähigkeiten
- Risikoabwägung und Entscheidungsfindung

**Systemverständnis:**
- Ursache-Wirkungs-Beziehungen in komplexen Systemen
- Gleichgewichtszustände und Balancing-Prinzipien
- Informationsasymmetrie und deren Auswirkungen

**Technische Bildung:**
- Client-Server-Architektur anhand praktischen Beispiels
- Netzwerk-Protokolle und Echtzeitkommunikation
- Game Design Prinzipien und User Experience

### Projektabschluss

"Pfeil und Krone" demonstriert erfolgreich die Umsetzung eines asymmetrischen Multiplayer-Spiels von der Konzeption bis zur funktionsfähigen Implementierung. Das Projekt vereint technische Komplexität mit zugänglichem Gameplay und schafft eine solide Basis für weitere Entwicklungen.

Die interdisziplinäre Zusammenarbeit zwischen Informatik- und Medieninformatik-Studierenden führte zu einem Produkt, das sowohl technisch robust als auch visuell ansprechend ist. Die gewählte Architektur unterstützt zukünftige Erweiterungen und bietet Lernmöglichkeiten für weitere Projekte.

Das Spiel erreicht sein Ziel, ein einzigartiges asymmetrisches Spielerlebnis zu schaffen, das die Stärken beider Rollen betont und strategische Tiefe durch die Verbindung von Ressourcenmanagement und Tower-Defense-Elementen erzeugt.

---

**Datum der Fertigstellung:** Januar 2025
**Projektdauer:** Ein Semester
**Entwicklungsstatus:** Produktionsreifer Prototyp mit vollständiger Spielmechanik
**Zukünftige Wartung:** Dokumentierte Architektur ermöglicht Weiterentwicklung durch nachfolgende Projekte